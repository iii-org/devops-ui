{
  "version": 3,
  "file": "svelteGantt.css",
  "sources": [
    "../../Gantt.svelte",
    "../../Column.svelte",
    "../../ColumnHeaderRow.svelte",
    "../../Columns.svelte",
    "../../Milestone.svelte",
    "../../Row.svelte",
    "../../Task.svelte",
    "../../TimeRange.svelte",
    "../../TimeRangeHeader.svelte",
    "../../Arrow.svelte",
    "../../Dependency.svelte",
    "../../GanttDependencies.svelte",
    "../../Table.svelte",
    "../../TableRow.svelte",
    "../../TableTreeCell.svelte",
    "../../ContextMenu.svelte",
    "../../Resizer.svelte"
  ],
  "sourcesContent": [
    "<script>\n    import {onMount, setContext, tick, onDestroy} from 'svelte';\n    import {writable, derived} from 'svelte/store';\n    import moment from 'moment';\n\n    let ganttElement;\n    let mainHeaderContainer;\n    let mainContainer;\n    let rowContainer;\n    let scrollables = [];\n    let mounted = false;\n\n    import {rowStore, taskStore, timeRangeStore, allTasks, allRows, allTimeRanges, rowTaskCache} from './core/store';\n    import {Task, Row, TimeRange, TimeRangeHeader, Milestone} from './entities';\n    import {Columns, ColumnHeader} from './column';\n    import {Resizer} from \"./ui\";\n\n    import {GanttUtils, getPositionByDate} from \"./utils/utils\";\n    import {getRelativePos, debounce, throttle} from \"./utils/domUtils\";\n    import {SelectionManager} from \"./utils/selectionManager\";\n    import {GanttApi} from \"./core/api\";\n    import {TaskFactory, reflectTask} from \"./core/task\";\n    import {RowFactory} from \"./core/row\";\n    import {TimeRangeFactory} from \"./core/timeRange\";\n    import {DragDropManager} from \"./core/drag\";\n    import {findByPosition, findByDate} from './core/column';\n    import {onEvent, onDelegatedEvent, offDelegatedEvent} from './core/events';\n\n    export let rows;\n    export let tasks = [];\n    export let timeRanges = [];\n    $: if (mounted) initRows(rows);\n    $: if (mounted) initTasks(tasks);\n    $: if (mounted) initTimeRanges(timeRanges);\n\n    export let rowPadding = 6;\n    export let rowHeight = 52;\n    const _rowHeight = writable(rowHeight);\n    const _rowPadding = writable(rowPadding);\n\n    export let from;\n    export let to;\n    const _from = writable(from);\n    const _to = writable(to);\n    $: $_from = from;\n    $: $_to = to;\n\n    export let minWidth = 800;\n    export let fitWidth = false;\n    const _minWidth = writable(minWidth);\n    const _fitWidth = writable(fitWidth);\n    $: {\n        $_minWidth = minWidth;\n        $_fitWidth = fitWidth;\n    }\n\n    export let classes = [];\n    export let headers = [{unit: 'day', format: 'MMMM Do'}, {unit: 'hour', format: 'H:mm'}];\n    export let zoomLevels = [\n        {\n            headers: [\n                {unit: 'day', format: 'DD.MM.YYYY'},\n                {unit: 'hour', format: 'HH'}\n            ],\n            minWidth: 800,\n            fitWidth: true\n        },\n        {\n            headers: [\n                {unit: 'hour', format: 'ddd D/M, H A'},\n                {unit: 'minute', format: 'mm', offset: 15}\n            ],\n            minWidth: 5000,\n            fitWidth: false\n        }\n    ];\n    export let taskContent = null;\n    export let tableWidth = 100;\n    export let resizeHandleWidth = 10;\n    export let onTaskButtonClick = null;\n    export let addButton = false\n    const _addButton = writable(addButton);\n    export let onAddButtonClick = null;\n\n    export let magnetUnit = 'minute';\n    export let magnetOffset = 15;\n    export let columnUnit = 'minute';\n    export let columnOffset = 15;\n\n    // export until Svelte3 implements Svelte2's setup(component) hook\n    export let ganttTableModules = [];\n    export let ganttBodyModules = [];\n\n    export let reflectOnParentRows = true;\n    export let reflectOnChildRows = false;\n\n    export let columnStrokeColor;\n    export let columnStrokeWidth;\n\n    const visibleWidth = writable();\n    const visibleHeight = writable();\n    const headerHeight = writable();\n    const _width = derived([visibleWidth, _minWidth, _fitWidth], ([visible, min, stretch]) => {\n        return stretch && visible > min ? visible : min;\n    });\n\n    export const columnService = {\n        getColumnByDate(date) {\n            const pair = findByDate(columns, date);\n            return !pair[0] ? pair[1] : pair[0];\n        },\n        getColumnByPosition(x) {\n            const pair = findByPosition(columns, x);\n            return !pair[0] ? pair[1] : pair[0];\n        },\n        getPositionByDate(date) {\n            if (!date) return null;\n            const column = this.getColumnByDate(date);\n\n            let durationTo = date.diff(column.from, 'milliseconds');\n            const position = durationTo / column.duration * column.width;\n\n            //multiples - skip every nth col, use other duration\n            return column.left + position;\n        },\n        getDateByPosition(x) {\n            const column = this.getColumnByPosition(x);\n            x = x - column.left;\n\n            let positionDuration = column.duration / column.width * x;\n            const date = moment(column.from).add(positionDuration, 'milliseconds');\n\n            return date;\n        },\n        /**\n         *\n         * @param {Moment} date - Date\n         * @returns {Moment} rounded date passed as parameter\n         */\n        roundTo(date) {\n            let value = date.get(magnetUnit);\n            value = Math.round(value / magnetOffset);\n            date.set(magnetUnit, value * magnetOffset);\n\n            //round all smaller units to 0\n            const units = ['millisecond', 'second', 'minute', 'hour', 'date', 'month', 'year'];\n            const indexOf = units.indexOf(magnetUnit);\n            for (let i = 0; i < indexOf; i++) {\n                date.set(units[i], 0)\n            }\n            return date\n        }\n    }\n\n    const columnWidth = writable(getPositionByDate($_from.clone().add(columnOffset, columnUnit), $_from, $_to, $_width) | 0);\n    $: $columnWidth = getPositionByDate($_from.clone().add(columnOffset, columnUnit), $_from, $_to, $_width) | 0;\n    let columnCount = Math.ceil($_width / $columnWidth);\n    $: columnCount = Math.ceil($_width / $columnWidth);\n    let columns = getColumns($_from, columnCount, columnOffset, columnUnit, $columnWidth);\n    $: columns = getColumns($_from, columnCount, columnOffset, columnUnit, $columnWidth);\n\n    function getColumns(from, count, offset, unit, width) {\n        let columns = [];\n        let columnFrom = from.clone();\n        let left = 0;\n        for (let i = 0; i < count; i++) {\n            const from = columnFrom.clone();\n            const to = columnFrom.add(offset, unit);\n            const duration = to.diff(from, 'milliseconds');\n\n            columns.push({\n                width: width,\n                from,\n                left,\n                duration\n            });\n            left += width;\n            columnFrom = to;\n        }\n\n        return columns;\n    }\n\n    const dimensionsChanged = derived([columnWidth, _from, _to], () => ({}));\n    $: {\n        if ($dimensionsChanged) {\n            refreshTasks();\n            refreshTimeRanges();\n        }\n    }\n\n    setContext('dimensions', {\n        from: _from,\n        to: _to,\n        width: _width,\n        visibleWidth,\n        visibleHeight,\n        headerHeight,\n        dimensionsChanged\n    });\n\n    setContext('options', {\n        taskContent,\n        rowPadding: _rowPadding,\n        rowHeight: _rowHeight,\n        resizeHandleWidth: resizeHandleWidth,\n        reflectOnParentRows,\n        reflectOnChildRows,\n        onTaskButtonClick,\n        addButton: _addButton,\n        onAddButtonClick\n    });\n\n    const hoveredRow = writable();\n    const selectedRow = writable();\n\n    const ganttContext = {\n        scrollables,\n        hoveredRow,\n        selectedRow\n    };\n    setContext('gantt', ganttContext);\n\n    onMount(() => {\n        Object.assign(ganttContext, {\n            rowContainer,\n            mainContainer,\n            mainHeaderContainer\n        });\n\n        api.registerEvent('tasks', 'move');\n        api.registerEvent('tasks', 'select');\n        api.registerEvent('tasks', 'switchRow');\n        api.registerEvent('tasks', 'moveEnd');\n        api.registerEvent('tasks', 'change');\n        api.registerEvent('tasks', 'changed');\n        api.registerEvent('gantt', 'viewChanged');\n\n        mounted = true;\n    });\n\n    onDelegatedEvent('click', 'data-task-id', (event, data, target) => {\n        const taskId = +data;\n        if (event.ctrlKey) {\n            selectionManager.toggleSelection(taskId);\n        } else {\n            selectionManager.selectSingle(taskId);\n        }\n        api.tasks.raise.select($taskStore.entities[taskId]);\n    });\n\n    onDelegatedEvent('mouseover', 'data-row-id', (event, data, target) => {\n        $hoveredRow = +data;\n    });\n\n    onDelegatedEvent('click', 'data-row-id', (event, data, target) => {\n        $selectedRow = +data;\n    });\n\n    onDestroy(() => {\n        offDelegatedEvent('click', 'data-task-id');\n        offDelegatedEvent('click', 'data-row-id');\n    });\n\n    let __scrollTop = 0;\n    let __scrollLeft = 0;\n\n    function scrollable(node) {\n        const onscroll = event => {\n            const {scrollTop, scrollLeft} = node;\n\n            scrollables.forEach(scrollable => {\n                if (scrollable.orientation === \"horizontal\") {\n                    scrollable.node.scrollLeft = scrollLeft;\n                } else {\n                    scrollable.node.scrollTop = scrollTop;\n                }\n            });\n\n            __scrollTop = scrollTop;\n            __scrollLeft = scrollLeft;\n        };\n\n        node.addEventListener(\"scroll\", onscroll);\n        return {\n            destroy() {\n                node.removeEventListener(\"scroll\", onscroll, false);\n            }\n        };\n    }\n\n    function horizontalScrollListener(node) {\n        scrollables.push({node, orientation: \"horizontal\"});\n    }\n\n    function onResize(event) {\n        tableWidth = event.detail.left;\n    }\n\n    let zoomLevel = 0;\n    let zooming = false;\n\n    async function onwheel(event) {\n        if (event.ctrlKey) {\n            event.preventDefault();\n\n            const prevZoomLevel = zoomLevel;\n            if (event.deltaY > 0) {\n                zoomLevel = Math.max(zoomLevel - 1, 0);\n            } else {\n                zoomLevel = Math.min(zoomLevel + 1, zoomLevels.length - 1);\n            }\n\n            if (prevZoomLevel != zoomLevel && zoomLevels[zoomLevel]) {\n                const options = {\n                    columnUnit: columnUnit,\n                    columnOffset: columnOffset,\n                    minWidth: $_minWidth,\n                    ...zoomLevels[zoomLevel]\n                };\n\n                const scale = options.minWidth / $_width;\n                const node = mainContainer;\n                const mousepos = getRelativePos(node, event);\n                const before = node.scrollLeft + mousepos.x;\n                const after = before * scale;\n                const scrollLeft = after - mousepos.x + node.clientWidth / 2;\n\n                console.log('scrollLeft', scrollLeft);\n\n                columnUnit = options.columnUnit;\n                columnOffset = options.columnOffset;\n                $_minWidth = options.minWidth;\n\n                if (options.headers)\n                    headers = options.headers;\n\n                if (options.fitWidth)\n                    $_fitWidth = options.fitWidth;\n\n                api.gantt.raise.viewChanged();\n                zooming = true;\n                await tick();\n                node.scrollLeft = scrollLeft;\n                zooming = false;\n            }\n        }\n    }\n\n    function onDateSelected(event) {\n        $_from = event.detail.from.clone();\n        $_to = event.detail.to.clone();\n    }\n\n    function initRows(rowsData) {\n        const rows = rowFactory.createRows(rowsData);\n        rowStore.addAll(rows);\n    }\n\n    async function initTasks(taskData) {\n        await tick();\n\n        const tasks = [];\n        const opts = {rowPadding: $_rowPadding};\n        taskData.forEach(t => {\n            const task = taskFactory.createTask(t);\n            const row = $rowStore.entities[task.model.resourceId];\n            task.reflections = [];\n\n            if (reflectOnChildRows && row.allChildren) {\n                row.allChildren.forEach(r => {\n                    const reflectedTask = reflectTask(task, r, opts);\n                    task.reflections.push(reflectedTask.model.id);\n                    tasks.push(reflectedTask);\n                });\n            }\n\n            if (reflectOnParentRows && row.allParents.length > 0) {\n                row.allParents.forEach(r => {\n                    const reflectedTask = reflectTask(task, r, opts);\n                    task.reflections.push(reflectedTask.model.id);\n                    tasks.push(reflectedTask);\n                });\n            }\n\n            tasks.push(task);\n        });\n        taskStore.addAll(tasks);\n    }\n\n    function initTimeRanges(timeRangeData) {\n        const timeRanges = timeRangeData.map(timeRange => {\n            return timeRangeFactory.create(timeRange);\n        });\n        timeRangeStore.addAll(timeRanges);\n    }\n\n    function onModuleInit(module) {\n\n    }\n\n    async function tickWithoutCSSTransition() {\n        disableTransition = false;\n        await tick();\n        ganttElement.offsetHeight; // force a reflow\n        disableTransition = true;\n    }\n\n    export const api = new GanttApi();\n    const selectionManager = new SelectionManager();\n\n    export const taskFactory = new TaskFactory(columnService);\n    $: {\n        taskFactory.rowPadding = $_rowPadding;\n        taskFactory.rowEntities = $rowStore.entities;\n    }\n\n    export const rowFactory = new RowFactory();\n    $: rowFactory.rowHeight = rowHeight;\n\n    export const dndManager = new DragDropManager(rowStore);\n    export const timeRangeFactory = new TimeRangeFactory(columnService);\n\n    export const utils = new GanttUtils();\n    $: {\n        utils.from = $_from;\n        utils.to = $_to;\n        utils.width = $_width;\n        utils.magnetOffset = magnetOffset;\n        utils.magnetUnit = magnetUnit;\n    }\n\n    setContext('services', {\n        utils,\n        api,\n        dndManager,\n        selectionManager,\n        columnService\n    });\n\n    export function refreshTimeRanges() {\n        timeRangeStore._update(({ids, entities}) => {\n            ids.forEach(id => {\n                const timeRange = entities[id];\n                const newLeft = columnService.getPositionByDate(timeRange.model.from) | 0;\n                const newRight = columnService.getPositionByDate(timeRange.model.to) | 0;\n\n                timeRange.left = newLeft;\n                timeRange.width = newRight - newLeft;\n            });\n            return {ids, entities};\n        });\n    }\n\n    export function refreshTasks() {\n        $allTasks.forEach(task => {\n            const newLeft = columnService.getPositionByDate(task.model.from) | 0;\n            const newRight = columnService.getPositionByDate(task.model.to) | 0;\n\n            task.left = newLeft;\n            task.width = newRight - newLeft;\n        });\n\n        taskStore.refresh();\n    }\n\n    export function getRowContainer() {\n        return rowContainer;\n    }\n\n    export function selectTask(id) {\n        const task = $taskStore.entities[id];\n        if (task) {\n            selectionManager.selectSingle(task);\n        }\n    }\n\n    export function unselectTasks() {\n        selectionManager.clearSelection();\n    }\n\n    export function scrollToRow(id, scrollBehavior = 'auto') {\n        const {scrollTop, clientHeight} = mainContainer;\n\n        const index = $allRows.findIndex(r => r.model.id == id);\n        if (index === -1) return;\n        const targetTop = index * rowHeight;\n\n        if (targetTop < scrollTop) {\n            mainContainer.scrollTo({\n                top: targetTop,\n                behavior: scrollBehavior\n            });\n        }\n\n        if (targetTop > scrollTop + clientHeight) {\n            mainContainer.scrollTo({\n                top: targetTop + rowHeight - clientHeight,\n                behavior: scrollBehavior\n            });\n        }\n    }\n\n    export function scrollToTask(id, scrollBehavior = 'auto') {\n        const {scrollLeft, scrollTop, clientWidth, clientHeight} = mainContainer;\n\n        const task = $taskStore.entities[id];\n        if (!task) return;\n        const targetLeft = task.left;\n        const rowIndex = $allRows.findIndex(r => r.model.id == task.model.resourceId);\n        const targetTop = rowIndex * rowHeight;\n\n        const options = {\n            top: undefined,\n            left: undefined,\n            behavior: scrollBehavior\n        };\n\n        if (targetLeft < scrollLeft) {\n            options.left = targetLeft;\n        }\n\n        if (targetLeft > scrollLeft + clientWidth) {\n            options.left = targetLeft + task.width - clientWidth;\n        }\n\n        if (targetTop < scrollTop) {\n            options.top = targetTop;\n        }\n\n        if (targetTop > scrollTop + clientHeight) {\n            options.top = targetTop + rowHeight - clientHeight;\n        }\n\n        mainContainer.scrollTo(options);\n    }\n\n    export function updateTask(model) {\n        const task = taskFactory.createTask(model);\n        taskStore.upsert(task);\n    }\n\n    export function updateTasks(taskModels) {\n        const tasks = taskModels.map(model => taskFactory.createTask(model));\n        taskStore.upsertAll(tasks);\n    }\n\n    export function updateRow(model) {\n        const row = rowFactory.createRow(model);\n        rowStore.upsert(row);\n    }\n\n    export function updateRows(rowModels) {\n        const rows = rowModels.map(model => rowFactory.createRow(model));\n        rowStore.upsertAll(rows);\n    }\n\n    export function getRow(resourceId) {\n        return $rowStore.entities[resourceId];\n    }\n\n    export function getTask(id) {\n        return $taskStore.entities[id];\n    }\n\n    export function getTasks(resourceId) {\n        if ($rowTaskCache[resourceId]) {\n            return $rowTaskCache[resourceId].map(id => $taskStore.entities[id]);\n        }\n        return null;\n    }\n\n    let filteredRows = [];\n    $: filteredRows = $allRows.filter(row => !row.hidden);\n\n    let rightScrollbarVisible;\n    $: rightScrollbarVisible = rowContainerHeight > $visibleHeight;\n\n    let rowContainerHeight;\n    $: rowContainerHeight = filteredRows.length * rowHeight;\n\n    let startIndex;\n    $: startIndex = Math.floor(__scrollTop / rowHeight);\n\n    let endIndex;\n    $: endIndex = Math.min(startIndex + Math.ceil($visibleHeight / rowHeight), filteredRows.length - 1);\n\n    let paddingTop = 0;\n    $: paddingTop = startIndex * rowHeight;\n\n    let paddingBottom = 0;\n    $: paddingBottom = (filteredRows.length - endIndex - 1) * rowHeight;\n\n    let visibleRows = [];\n    $: visibleRows = filteredRows.slice(startIndex, endIndex + 1);\n\n    let visibleTasks;\n    $: {\n        const tasks = [];\n        visibleRows.forEach(row => {\n            if ($rowTaskCache[row.model.id]) {\n                $rowTaskCache[row.model.id].forEach(id => {\n                    tasks.push($taskStore.entities[id]);\n                });\n            }\n        });\n        visibleTasks = tasks;\n    }\n\n    let disableTransition = true;\n    $: if ($dimensionsChanged) tickWithoutCSSTransition();\n</script>\n\n<div class=\"sg-gantt {classes}\" class:sg-disable-transition={!disableTransition} bind:this={ganttElement}\n     on:click={onEvent} on:mouseover={onEvent}>\n    {#each ganttTableModules as module}\n        <svelte:component this={module} {rowContainerHeight} {paddingTop} {paddingBottom} tableWidth={tableWidth}\n                          {...$$restProps} on:init=\"{onModuleInit}\" {visibleRows}/>\n\n        <Resizer x={tableWidth} on:resize=\"{onResize}\" container={ganttElement}></Resizer>\n    {/each}\n\n    <div class=\"sg-timeline sg-view\">\n        <div class=\"sg-header\" bind:this={mainHeaderContainer} bind:clientHeight=\"{$headerHeight}\"\n             class:right-scrollbar-visible=\"{rightScrollbarVisible}\">\n            <div class=\"sg-header-scroller\" use:horizontalScrollListener>\n                <div class=\"header-container\" style=\"width:{$_width}px\">\n                    <ColumnHeader {headers} {columnUnit} {columnOffset} on:dateSelected=\"{onDateSelected}\"/>\n                    {#each $allTimeRanges as timeRange (timeRange.id)}\n                        <TimeRangeHeader {...timeRange}/>\n                    {/each}\n                </div>\n            </div>\n        </div>\n\n        <div class=\"sg-timeline-body\" bind:this={mainContainer} use:scrollable class:zooming=\"{zooming}\"\n             on:wheel=\"{onwheel}\"\n             bind:clientHeight=\"{$visibleHeight}\" bind:clientWidth=\"{$visibleWidth}\">\n            <div class=\"content\" style=\"width:{$_width}px\">\n                <Columns columns={columns} {columnStrokeColor} {columnStrokeWidth}/>\n                <div class=\"sg-rows\" bind:this={rowContainer} style=\"height:{rowContainerHeight}px;\">\n                    <div style=\"transform: translateY({paddingTop}px);\">\n                        {#each visibleRows as row (row.model.id)}\n                            <Row row={row}/>\n                        {/each}\n                    </div>\n                </div>\n                <div class=\"sg-foreground\">\n                    {#each $allTimeRanges as timeRange (timeRange.id)}\n                        <TimeRange {...timeRange}/>\n                    {/each}\n\n                    {#each visibleTasks as task (task.model.id)}\n                        <Task model={task.model} left={task.left}\n                              width={task.width} height={task.height} top={task.top} {...task}/>\n                    {/each}\n                </div>\n                {#each ganttBodyModules as module}\n                    <svelte:component this={module} {paddingTop} {paddingBottom} {visibleRows} {...$$restProps}\n                                      on:init=\"{onModuleInit}\"/>\n                {/each}\n            </div>\n        </div>\n    </div>\n</div>\n\n<style>\n    .sg-disable-transition :global(.sg-task),\n    .sg-disable-transition :global(.sg-milestone) {\n        transition: transform 0s, background-color 0.2s, width 0s !important;\n    }\n\n    :global(.sg-view:not(:first-child)) {\n        margin-left: 5px;\n    }\n\n    /* This class should take into account varying widths of the scroll bar */\n    .right-scrollbar-visible {\n        padding-right: 17px;\n    }\n\n    .sg-timeline {\n        flex: 1 1 0%;\n        display: flex;\n        flex-direction: column;\n        overflow-x: auto;\n    }\n\n    .sg-gantt {\n        display: flex;\n\n        width: 100%;\n        height: 100%;\n        position: relative;\n    }\n\n    .sg-foreground {\n        box-sizing: border-box;\n        overflow: hidden;\n        top: 0;\n        left: 0;\n        position: absolute;\n        width: 100%;\n        height: 100%;\n        z-index: 1;\n        pointer-events: none;\n    }\n\n    .sg-rows {\n        width: 100%;\n        box-sizing: border-box;\n        overflow: hidden;\n    }\n\n    .sg-timeline-body {\n        overflow: auto;\n        flex: 1 1 auto;\n    }\n\n    .sg-header {\n\n    }\n\n    .header-container {\n    }\n\n    .sg-header-scroller {\n        border-right: 1px solid #efefef;\n        overflow: hidden;\n        position: relative;\n    }\n\n    .content {\n        position: relative;\n    }\n\n    :global(*) {\n        box-sizing: border-box;\n    }\n</style>",
    "<script>\n    export let left;\n    export let width;\n</script>\n\n<div class=\"column\" style=\"left:{left}px;width:{width}px\"></div>\n<style>\n    .column {\n        position: absolute;\n        height: 100%;\n        box-sizing: border-box;\n    }\n    \n    .column {\n        border-right: #efefef 1px solid;\n    }\n</style>",
    "<script>\n    import { createEventDispatcher, getContext } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    import { duration as momentDuration } from 'moment';\n\n    const { from, to, width } = getContext('dimensions');\n    \n    export let header;\n    export let baseWidth;\n    export let baseDuration;\n\n    export let columnWidth;\n    $: {\n        const offset = header.offset || 1;\n        const duration = momentDuration(offset, header.unit).asMilliseconds();\n        const ratio = duration / baseDuration;\n        columnWidth = baseWidth * ratio;\n    }\n\n    export let columnCount;\n    $: {\n        columnCount = Math.ceil($width / columnWidth);\n        if(!isFinite(columnCount)){\n            console.error('columnCount is not finite');\n            columnCount = 0;\n        }\n    }\n\n    let _headers = [];\n    $: {\n        const headers = [];\n        let headerTime = $from.clone().startOf(header.unit);\n        const offset = header.offset || 1;\n\n        for(let i = 0; i < columnCount; i++){\n            headers.push({\n                width: Math.min(columnWidth, $width), \n                label: headerTime.format(header.format),\n                from: headerTime.clone(),\n                to: headerTime.clone().add(offset, header.unit),\n                unit: header.unit\n            });\n            headerTime.add(offset, header.unit);\n        }\n        _headers = headers;\n    }\n</script>\n\n<div class=\"column-header-row\">\n    {#each _headers as _header}\n        <div class=\"column-header-cell\" class:sticky={header.sticky} style=\"width:{_header.width}px\" on:click=\"{() => dispatch('dateSelected', { from: _header.from, to: _header.to, unit: _header.unit })}\">\n            <div class=\"column-header-cell-label\">{_header.label || 'N/A'}</div>\n        </div>\n    {/each}\n</div>\n<style>\n    .column-header-row {\n        box-sizing: border-box;\n        white-space: nowrap;\n        height: 32px;\n    }\n\n    .column-header-cell {\n        display: inline-block;\n        height: 100%;\n        box-sizing: border-box;\n        text-overflow: clip;\n        /* vertical-align: top; */\n        text-align: center;\n\n        display: inline-flex;\n        justify-content: center;\n        align-items: center;\n        font-size: 1em;    \n        font-size: 14px;\n        font-weight: 300;\n        transition: background 0.2s;\n\n        cursor: pointer;     \n        user-select: none;\n\n        border-right: #efefef 1px solid;\n        border-bottom: #efefef 1px solid;\n    }\n\n    .column-header-cell:hover {\n        background: #f9f9f9;\n    }\n\n    .column-header-cell.sticky > .column-header-cell-label {\n        position: sticky;\n        left: 1rem;\n    }\n</style>",
    "<script>\n    import { getContext, onMount } from 'svelte';\n    \n    import Column from './Column.svelte';\n    /**\n     * Container component for columns rendered as gantt body background\n     */\n    export let columns = [];\n\n    export let columnStrokeWidth = 1;\n    export let columnStrokeColor = '#efefef';\n\n    function lineAt(ctx, x) {\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, 20);\n        ctx.stroke();\n    }\n\n    function createBackground(columns) {\n        const canvas = document.createElement('canvas');\n        canvas.width = (columns.length - 1) * columns[0].width;\n        canvas.height = 20;\n\n        const ctx = canvas.getContext('2d');\n        ctx.shadowColor = \"rgba(128,128,128,0.5)\";\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n        ctx.shadowBlur = 0.5;\n        ctx.lineWidth = columnStrokeWidth;\n        ctx.lineCap = \"square\";\n        ctx.strokeStyle = columnStrokeColor;\n        ctx.translate(0.5, 0.5);\n\n        columns.forEach(column => {\n            lineAt(ctx, column.left);\n        });\n\n        const dataURL = canvas.toDataURL();\n        return `url(\"${dataURL}\")`;\n    }\n\n    let backgroundImage;\n    $: {\n        backgroundImage = createBackground(columns.slice(0,5));\n    }\n</script>\n\n<div class=\"sg-columns\" style=\"background-image:{backgroundImage};\">\n\t<!-- {#each columns as column}\n\t<Column left={column.left} width={column.width} />\n\t{/each} -->\n</div>\n<style>\n    .sg-columns {\n        position: absolute;\n        height: 100%;\n        width: 100%;\n        overflow: hidden;\n\n        background-repeat: repeat;\n        background-position-x: -1px;\n    }\n</style>",
    "<script>\n    import { beforeUpdate, onMount, getContext } from 'svelte';\n\n    let milestoneElement;\n\n    import { Draggable } from '../core/drag';\n    import { rowStore, taskStore } from '../core/store';\n    const { rowPadding } = getContext('options');\n    const { selectionManager, api, rowContainer, dndManager, columnService} = getContext('services');\n\n    export let left;\n    export let top;\n    export let model;\n    export let height = 20;\n\n    const selection = selectionManager.selection;\n\n    let dragging = false;\n    let x = null;\n    let y = null;\n    $: {\n        if(!dragging){\n            x = left, y = top;\n        }\n    }\n\n    function drag(node) {\n        const ondrop = ({ x, y, currWidth, event, dragging }) => {\n            let rowChangeValid = true;\n            //row switching\n            if(dragging){\n                const sourceRow = $rowStore.entities[model.resourceId];\n                const targetRow = dndManager.getTarget('row', event);\n                if(targetRow){\n                    model.resourceId = targetRow.model.id;\n                    api.tasks.raise.switchRow(this, targetRow, sourceRow);\n                }\n                else{\n                    rowChangeValid = false;\n                }\n            }\n            \n            dragging = false;\n            const task = $taskStore.entities[model.id];\n            if(rowChangeValid) {\n                const newFrom = utils.roundTo(columnService.getDateByPosition(x)); \n                const newLeft = columnService.getPositionByDate(newFrom);\n\n                Object.assign(model, {\n                    from: newFrom\n                });\n                \n                $taskStore.update({\n                    ...task,\n                    left: newLeft,\n                    top: rowPadding + $rowStore.entities[model.resourceId].y,\n                    model\n                });\n            }\n            else {\n                // reset position\n                $taskStore.update({\n                    ...task\n                });\n            }\n        }\n\n        const draggable = new Draggable(node, {\n            onDown: ({x, y}) => {\n                //this.set({x, y});\n            }, \n            onDrag: (pos) => {\n                x = pos.x, y = pos.y, dragging = true;\n            },\n            dragAllowed: () => {\n                return row.model.enableDragging && model.enableDragging;\n            },\n            resizeAllowed: false,\n            onDrop: ondrop, \n            container: rowContainer, \n            getX: () => x,\n            getY: () => y\n        });\n\n        return {\n            destroy() { draggable.destroy(); }\n        }\n    }\n\n    onMount(() => {\n        x = left = columnService.getPositionByDate(model.from); \n        y = top = row.y + $rowPadding;; \n        height = row.height - 2 * $rowPadding;\n    });\n\n    export function select(event) {\n        if(event.ctrlKey){\n            selectionManager.toggleSelection(model.id);\n        }\n        else{\n            selectionManager.selectSingle(model.id);\n        }\n        \n        if(selected){\n            api.tasks.raise.select(model);\n        }\n    }\n\n    let selected = false;\n    $: selected = $selection.indexOf(model.id) !== -1;\n\n    let row;\n    $: row = $rowStore.entities[model.resourceId];\n</script>\n\n<div bind:this={milestoneElement}\n    class=\"sg-milestone {model.classes}\" \n    style=\"transform: translate({x}px, {y}px);height:{height}px;width:{height}px\"\n    use:drag \n    on:click=\"{select}\"\n    class:selected=\"{selected}\"\n    class:moving=\"{dragging}\">\n    <div class=\"inside\"></div>\n        <!-- <span class=\"debug\">x:{x|0} y:{y|0}, x:{left|0} y:{top|0}</span> -->\n</div>\n\n<style>\n    .sg-milestone {\n\t\tposition: absolute;     \n        top: 0;\n        bottom: 0;\n\n        white-space: nowrap;\n        /* overflow: hidden; */\n\n        height: 20px;\n        width: 20px;\n\n        min-width: 40px;\n        margin-left: -20px;\n        display: flex;\n        align-items: center;\n        flex-direction: column;\n\n        transition: background-color 0.2s, opacity 0.2s;\n    }\n\n    .sg-milestone .inside {\n        position: relative;\n    }\n\n    .sg-milestone .inside:before {\n        position: absolute;\n        top: 0;\n        left: 0;\n        content: ' ';\n        height: 28px;\n        width: 28px;\n        transform-origin: 0 0;\n        transform: rotate(45deg); \n        /* //after -45 */\n        background-color: #feac31;\n        border-color: #feac31;\n    }\n\n    .sg-milestone:not(.moving) {\n        transition: transform 0.2s, background-color 0.2s, width 0.2s;\n    }\n\n    .sg-milestone.moving{\n        z-index: 1;\n    }\n\n    .sg-milestone.selected {\n        outline: 2px solid rgba(3, 169, 244, 0.5);\n        outline-offset: 3px;\n        z-index: 1;\n    }\n</style>",
    "<script>\n    import { getContext } from 'svelte';\n    export let row;\n    let rowElement;\n\n    const { rowHeight } = getContext('options');\n    const { hoveredRow, selectedRow } = getContext('gantt');\n</script>\n\n<div class=\"sg-row {row.model.classes}\" data-row-id=\"{row.model.id}\" class:sg-hover={$hoveredRow == row.model.id} class:sg-selected={$selectedRow == row.model.id} bind:this={rowElement} style=\"height:{$rowHeight}px\">\n    {#if row.model.contentHtml}\n        {@html row.model.contentHtml}\n    {/if}\n</div>    \n<style>\n    .sg-row {\n        position: relative;\n        width: 100%;\n        box-sizing: border-box;\n    }\n</style>",
    "<script>\n    import { beforeUpdate, afterUpdate, getContext, onMount, onDestroy, tick } from \"svelte\";\n\n    import { setCursor } from \"src/utils/domUtils\";\n    import { taskStore, rowStore } from '../core/store';\n    import { Draggable } from \"../core/drag\";\n    import { reflectTask } from \"src/core/task\";\n\n    export let model;\n    export let height;\n    export let left;\n    export let top;\n    export let width;\n    export let reflected = false;\n\n    let animating = true;\n\n    let _dragging = false;\n    let _resizing = false;\n\n    let _position = {\n        x: left,\n        y: top,\n        width: width,\n    }\n\n    $: updatePosition(left, top, width);\n    function updatePosition(x, y, width) {\n        if(!_dragging && !_resizing) {\n            _position.x = x;\n            _position.y = y;//row.y + 6;\n            _position.width = width;\n            // should NOT animate on resize/update of columns\n        }\n    }\n\n    const { dimensionsChanged } = getContext('dimensions');\n    const { rowContainer } = getContext('gantt');\n    const { taskContent, resizeHandleWidth, rowPadding, onTaskButtonClick, reflectOnParentRows, reflectOnChildRows } = getContext('options');\n    const { dndManager, api, utils, selectionManager, columnService } = getContext('services');\n\n    function drag(node) {\n        const ondrop = (event) => {\n            let rowChangeValid = true;\n            //row switching\n            const sourceRow = $rowStore.entities[model.resourceId];\n            if (event.dragging) {\n                const targetRow = dndManager.getTarget(\"row\", event.mouseEvent);\n                if (targetRow) {\n                    model.resourceId = targetRow.model.id;\n                    api.tasks.raise.switchRow(this, targetRow, sourceRow);\n                } else {\n                    rowChangeValid = false;\n                }\n            }\n\n            _dragging = _resizing = false;\n\n            const task = $taskStore.entities[model.id];\n\n            if (rowChangeValid) {\n                const prevFrom = model.from;\n                const prevTo = model.to;\n                const newFrom = model.from = utils.roundTo(columnService.getDateByPosition(event.x));\n                const newTo = model.to = utils.roundTo(columnService.getDateByPosition(event.x + event.width));\n                const newLeft = columnService.getPositionByDate(newFrom) | 0;\n                const newRight = columnService.getPositionByDate(newTo) | 0;\n\n                const targetRow = $rowStore.entities[model.resourceId];\n                const left = newLeft;\n                const width = newRight - newLeft;\n                const top = $rowPadding + targetRow.y;\n                \n                updatePosition(left, top, width);\n\n                const newTask = {\n                    ...task,\n                    left: left,\n                    width: width,\n                    top: top,\n                    model\n                }\n\n                const changed = !prevFrom.isSame(newFrom) || !prevTo.isSame(newTo) || (sourceRow && sourceRow.model.id !== targetRow.model.id);\n                if(changed) {\n                    api.tasks.raise.change({ task: newTask, sourceRow, targetRow });\n                }\n\n                taskStore.update(newTask);\n\n                if(changed) {\n                    api.tasks.raise.changed({ task: newTask, sourceRow, targetRow });\n                }\n\n                // update shadow tasks\n                if(newTask.reflections) {\n                    taskStore.deleteAll(newTask.reflections);\n                }\n\n                const reflectedTasks = [];\n                if(reflectOnChildRows && targetRow.allChildren) {\n                    if(!newTask.reflections)\n                        newTask.reflections = [];\n\n                    const opts = { rowPadding: $rowPadding };\n                    targetRow.allChildren.forEach(r => {\n                        const reflectedTask = reflectTask(newTask, r, opts);\n                        newTask.reflections.push(reflectedTask.model.id);\n                        reflectedTasks.push(reflectedTask);\n                    });\n                }\n\n                if(reflectOnParentRows && targetRow.allParents.length > 0) {\n                    if(!newTask.reflections)\n                        newTask.reflections = [];\n\n                    const opts = { rowPadding: $rowPadding };\n                    targetRow.allParents.forEach(r => {\n                        const reflectedTask = reflectTask(newTask, r, opts);\n                        newTask.reflections.push(reflectedTask.model.id);\n                        reflectedTasks.push(reflectedTask);\n                    });\n                }\n\n                if(reflectedTasks.length > 0) {\n                    taskStore.upsertAll(reflectedTasks);\n                }\n\n                if(!(targetRow.allParents.length > 0) && !targetRow.allChildren) {\n                    newTask.reflections = null;\n                }\n            }\n            else {\n                // reset position\n                (_position.x = task.left), (_position.width = task.width), (_position.y = task.top);\n            }\n        };\n\n        const draggable = new Draggable(node, {\n            onDown: (event) => {\n                if (event.dragging) {\n                    setCursor(\"move\");\n                }\n                if (event.resizing) {\n                    setCursor(\"e-resize\");\n                }\n            },\n            onMouseUp: () => {\n                setCursor(\"default\");\n            },\n            onResize: (event) => {\n                (_position.x = event.x), (_position.width = event.width), (_resizing = true);\n            },\n            onDrag: (event) => {\n                (_position.x = event.x), (_position.y = event.y), (_dragging = true);\n            },\n            dragAllowed: () => {\n                return row.model.enableDragging && model.enableDragging;\n            },\n            resizeAllowed: () => {\n                return row.model.enableDragging && model.enableDragging;\n            },\n            onDrop: ondrop,\n            container: rowContainer,\n            resizeHandleWidth, \n            getX: () => _position.x,\n            getY: () => _position.y,\n            getWidth: () => _position.width\n        });\n        return {\n            destroy: () => draggable.destroy()\n        };\n    }\n\n    export function onclick(event) {\n        if (onTaskButtonClick) {\n            onTaskButtonClick(task);\n        }\n    }\n\n    let selection = selectionManager.selection;\n    let selected = false;\n    $: selected = $selection.indexOf(model.id) !== -1;\n\n    let row;\n    $: row = $rowStore.entities[model.resourceId];\n</script>\n\n<style>\n    .sg-label-bottom {\n        position: absolute;\n        top: calc(100% + 10px);\n        color: #888;\n    }\n\n    .debug {\n        position: absolute;\n        top: -10px;\n        right: 0;\n        font-size: 8px;\n        color: black;\n    }\n\n    .sg-task {\n        position: absolute;\n\n        white-space: nowrap;\n        /* overflow: hidden; */\n\n        transition: background-color 0.2s, opacity 0.2s;\n        pointer-events: all;\n    }\n\n    .sg-task-background {\n        position: absolute;\n        height: 100%;\n        top: 0;\n    }\n\n    .sg-task-content {\n        position: absolute;\n        height: 100%;\n        top: 0;\n\n        padding-left: 14px;\n        font-size: 14px;\n        display: flex;\n        align-items: center;\n        justify-content: flex-start;\n    }\n\n    .sg-task:not(.moving) {\n        transition: transform 0.2s, background-color 0.2s, width 0.2s;\n    }\n\n    .sg-task.moving {\n        z-index: 1;\n        opacity: 0.5;\n    }\n\n    .sg-task:hover::before {\n        content: \"\";\n        width: 4px;\n        height: 50%;\n        top: 25%;\n        position: absolute;\n        cursor: ew-resize;\n        border-style: solid;\n        border-color: rgba(255, 255, 255, 0.5);\n\n        margin-left: 3px;\n        left: 0;\n        border-width: 0 1px;\n        z-index: 1;\n    }\n\n    .sg-task:hover::after {\n        content: \"\";\n        width: 4px;\n        height: 50%;\n        top: 25%;\n        position: absolute;\n        cursor: ew-resize;\n        border-style: solid;\n        border-color: rgba(255, 255, 255, 0.5);\n\n        margin-right: 3px;\n        right: 0;\n        border-width: 0 1px;\n        z-index: 1;\n    }\n\n    .sg-task.selected {\n        outline: 2px solid rgba(3, 169, 244, 0.5);\n        outline-offset: 3px;\n        z-index: 1;\n    }\n\n    .sg-task-reflected {\n        opacity: 0.5;\n    }\n\n    .sg-task-background {\n        background: rgba(0, 0, 0, 0.2);\n    }\n\n    :global(.sg-task) {\n        color: white;\n        background: rgb(116, 191, 255);\n    }\n\n    :global(.sg-task:hover) {\n        background: rgb(98, 161, 216);\n    }\n\n    :global(.sg-task.selected) {\n        background: rgb(69, 112, 150);\n    }\n</style>\n\n<div\n  data-task-id=\"{model.id}\"\n  use:drag\n  class=\"sg-task {model.classes}\"\n  style=\"width:{_position.width}px; height:{height}px; transform: translate({_position.x}px, {_position.y}px);\"\n  class:moving={_dragging || _resizing}\n  class:selected\n  class:animating\n  class:sg-task-reflected={reflected}>\n  {#if model.amountDone}\n  <div class=\"sg-task-background\" style=\"width:{model.amountDone}%\" />\n  {/if}\n  <div class=\"sg-task-content\">\n    {#if model.html}\n      {@html model.html}\n    {:else if taskContent}\n      {@html taskContent(model)}\n    {:else}{model.label}{/if}\n    <!-- <span class=\"debug\">x:{_position.x} y:{_position.y}, x:{left} y:{top}</span> -->\n    {#if model.showButton}\n      <span class=\"sg-task-button {model.buttonClasses}\" on:click={onclick}>\n        {@html model.buttonHtml}\n      </span>\n    {/if}\n  </div>\n\n  {#if model.labelBottom}\n    <label class=\"sg-label-bottom\">{model.labelBottom}</label>\n  {/if}\n</div>\n",
    "<script>\n    export let model;\n    export let left;\n    export let width;\n    export let resizing = false;\n\n    const _position = {\n        width,\n        x: left\n    }\n    $: {\n        _position.x = left, _position.width = width;\n    };\n</script>\n\n<div class=\"sg-time-range\" class:moving=\"{resizing}\" style=\"width:{_position.width}px;left:{_position.x}px\">\n    <div class=\"sg-time-range-label\">{model.label}</div>\n</div>\n<style>\n    .sg-time-range {\n        height: 100%;\n        position: absolute;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n\n        background-image: linear-gradient(-45deg, rgba(0, 0, 0, 0) 46%, #e03218 49%, #e03218 51%, rgba(0, 0, 0, 0) 55%);\n        background-size: 6px 6px !important;\n        color: red;\n        font-weight: 400;\n    }\n\n    .sg-time-range-label {\n        margin-top: 10px;\n        background: #fff;\n        white-space: nowrap;\n        padding: 4px;\n        font-weight: 400;\n        font-size: 10px;\n    }\n</style>",
    "<script>\n    import { beforeUpdate, getContext } from 'svelte';\n\n    import { Draggable } from '../core/drag';\n    import { timeRangeStore } from '../core/store';\n\n    const { rowContainer } = getContext('gantt');\n    const { utils, columnService } = getContext('services');\n    const { resizeHandleWidth } = getContext('options');\n    const {\n        from,\n        to,\n        width: ganttWidth,\n        visibleWidth\n    } = getContext('dimensions');\n\n    export let model;\n    export let width;\n    export let left;\n    \n    const _position = {\n        width,\n        x: left\n    }\n    $: {\n        _position.x = left, _position.width = width;\n    };\n\n    function drag(node) {\n        const ondrop = (event) => {\n            const newFrom = utils.roundTo(columnService.getDateByPosition(event.x)); \n            const newTo = utils.roundTo(columnService.getDateByPosition(event.x + event.width));\n            const newLeft = columnService.getPositionByDate(newFrom);\n            const newRight = columnService.getPositionByDate(newTo);\n            \n            Object.assign(model, {\n                from: newFrom,\n                to: newTo\n            });\n\n            update({\n                left: newLeft,\n                width: newRight - newLeft,\n                model,\n                resizing: false\n            });\n\n            window.removeEventListener('mousemove', onmousemove, false);\n        };\n\n        function update(state) {\n            timeRangeStore.update(state);\n            _position.x = state.left;\n            _position.width = state.width;\n        }\n\n        return new Draggable(node, {\n            onDown: (event) => {\n                update({\n                    left: event.x,\n                    width: event.width,\n                    model,\n                    resizing: true\n                });\n            }, \n            onResize: (event) => {\n                update({\n                    left: event.x,\n                    width: event.width,\n                    model,\n                    resizing: true\n                });\n            },\n            dragAllowed: false,\n            resizeAllowed: true,\n            onDrop: ondrop, \n            container: rowContainer, \n            resizeHandleWidth,\n            getX: () => _position.x,\n            getY: () => 0,\n            getWidth: () => _position.width\n        });\n    }\n</script>\n\n<div class=\"sg-time-range-control\" style=\"width:{_position.width}px;left:{_position.x}px\">\n    <div class=\"sg-time-range-handle-left\" use:drag></div>\n    <div class=\"sg-time-range-handle-right\" use:drag></div>\n</div>\n<style>\n    .sg-time-range-control {\n        position: absolute;\n    }\n\n    .sg-time-range-handle-left {\n        position: absolute;\n        left: 0;\n    }\n\n    .sg-time-range-handle-right {\n        position: absolute;\n        right: 0;\n    }\n\n    .sg-time-range-handle-left::before, .sg-time-range-handle-right::before {\n        position: absolute;\n        content: '';\n        bottom: 4px;\n        border-radius: 6px 6px 6px 0;\n        border: 2px solid #b0b0b7;\n        width: 9px;\n        height: 9px;\n        transform: translateX(-50%) rotate(-45deg);\n        background-color: #fff;\n\n        border-color: #e03218;\n        cursor: ew-resize;\n    }\n</style>",
    "<script>\n    import { onMount } from 'svelte';\n\n    export let startY;\n    export let endY;\n    export let endX;\n    export let startX;\n    export let minLen = 12;\n    export let arrowSize = 5;\n    export let stroke = 'red';\n    export let strokeWidth = 2;\n\n    onMount(() => {\n\n    });\n\n    let height;\n    $: height = endY - startY;\n\n    let width;\n    $: width = endX - startX;\n\n    let path;\n    $: {\n        if (startX == NaN || startX == undefined)\n            path = 'M0 0';\n\n        let result;\n        if (startX + minLen >= endX && startY != endY) {\n            result = `L ${startX + minLen} ${startY} \n                        L ${startX + minLen} ${startY + height / 2}\n                        L ${endX - minLen} ${startY + height / 2}\n                        L ${endX - minLen} ${endY} `\n        }\n        else {\n            result = `L ${startX + width / 2} ${startY} \n                        L ${startX + width / 2} ${endY}`\n        }\n\n        // -2 so the line doesn't stick out of the arrowhead\n        path = `M${startX} ${startY}` + result + `L ${endX - 2} ${endY}`\n    }\n\n    let arrowPath;\n    $: {\n        if (endX == NaN || endX == undefined)\n            arrowPath = 'M0 0';\n\n        arrowPath = `M${endX - arrowSize} ${endY - arrowSize} L${endX} ${endY} L${endX - arrowSize} ${endY + arrowSize} Z`\n    }\n</script>\n\n<svg xmlns=\"http://www.w3.org/2000/svg\" shape-rendering=\"crispEdges\" class=\"arrow\" height=\"100%\" width=\"100%\">\n    <path d=\"{path}\" {stroke} stroke-width=\"{strokeWidth}\" fill=\"transparent\" class=\"select-area\" />\n    <path d=\"{arrowPath}\" fill=\"{stroke}\" />\n</svg>\n\n<style>\n    .arrow {\n        position: absolute;\n        left: 0px;\n        pointer-events: none;\n    }\n\n    .select-area {\n        pointer-events: visible;\n        position: absolute;\n    }\n</style>",
    "<script>\n    import Arrow from './Arrow.svelte';\n\n    import { taskStore } from '../../core/store';\n\n    export let id;\n    export let fromId;\n    export let toId;\n\n    let fromTask;\n    $: fromTask = $taskStore.entities[fromId];\n\n    let toTask;\n    $: toTask = $taskStore.entities[toId];\n</script>\n\n<div class=\"sg-dependency\" style=\"left:0;top:0\" data-dependency-id=\"{id}\">\n    <Arrow startX={fromTask.left + fromTask.width} startY={fromTask.top + fromTask.height / 2} endX={toTask.left}\n        endY={toTask.top + toTask.height / 2} />\n</div>\n\n<style>\n    .sg-dependency {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n    }\n</style>",
    "<script context=\"module\">\n    const type = 'body';\n</script>\n\n<script>\n    import { getContext } from 'svelte';\n\n    import Dependency from './Dependency.svelte';\n    \n    import { taskStore } from '../../core/store';\n\n    const { visibleHeight } = getContext('dimensions');\n\n    export let paddingTop;\n    export let dependencies = [];\n\n    let visibleDependencies = [];\n    $: {\n        const result = [];\n        for (let i = 0; i < dependencies.length; i++) {\n            const dependency = dependencies[i];\n            const map = $taskStore.entities;\n\n            const fromTask = map[dependency.fromId];\n            const toTask = map[dependency.toId];\n            if(\n                fromTask && toTask \n                && Math.min(fromTask.top, toTask.top) <= paddingTop + $visibleHeight \n                && Math.max(fromTask.top, toTask.top) >= paddingTop\n            ) {\n                result.push(dependency);\n            }\n        }\n        visibleDependencies = result;\n    }\n</script>\n\n<div class=\"dependency-container\">\n    {#each visibleDependencies as dependency (dependency.id)}\n        <Dependency {...dependency}/>\n    {/each}\n</div>\n\n<style>\n    .dependency-container {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n        \n        pointer-events: none;\n        top: 0;\n        float: left;\n        overflow: hidden;\n        z-index: 0;\n    }\n</style>",
    "<script context=\"module\">\n    export const type = 'table';\n</script>\n\n<script>\n    import { createEventDispatcher, onMount, getContext } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    import TableRow from './TableRow.svelte';\n    import { H_SCROLLBAR_WIDTH } from 'src/core/constants';\n    import { rowStore, taskStore } from \"../../core/store\";\n\n    export let tableWidth;\n    export let paddingTop;\n    export let paddingBottom;\n    export let rowContainerHeight;\n    export let visibleRows;\n    // list of columns used in the table\n    // title: label to display in the header\n    // property: property of row to display in the cell\n    // width: width of column\n    export let tableHeaders = [{ title: 'Name', property: 'label', width: 100 }];\n\n    const { from, to, width, visibleWidth, headerHeight } = getContext('dimensions');\n    const { rowPadding } = getContext('options');\n\n    onMount(() => {\n        dispatch('init', { module: this });\n    });\n\n    const { scrollables } = getContext('gantt');\n    let headerContainer;\n    function scrollListener(node) {\n        scrollables.push({ node, orientation: \"vertical\" });\n        \n        node.addEventListener(\"scroll\", event => {\n            headerContainer.scrollLeft = node.scrollLeft;\n        });\n\n        return {\n            destroy() {\n                node.removeEventListener(\"scroll\");\n            }\n        };\n    }\n    \n    let scrollWidth;\n    $: {\n        let sum = 0;\n        tableHeaders.forEach(header => {\n            sum += header.width;\n        });\n        scrollWidth = sum;\n    }\n\n    function onRowExpanded(event) {\n        const row = event.detail.row;\n        row.expanded = true;\n        if(row.children)\n            show(row.children);\n        updateYPositions();\n    }\n\n    function onRowCollapsed(event) {\n        const row = event.detail.row;\n        row.expanded = false;\n        if(row.children)\n            hide(row.children);\n        updateYPositions();\n    }\n\n    function updateYPositions() {\n        let y = 0;\n        $rowStore.ids.forEach(id => {\n            const row = $rowStore.entities[id];\n            if(!row.hidden) {\n                $rowStore.entities[id].y = y;\n                y+= 52; \n            }\n        });\n\n        $taskStore.ids.forEach(id => {\n            const task = $taskStore.entities[id];\n            const row = $rowStore.entities[task.model.resourceId];\n            $taskStore.entities[id].top = row.y + $rowPadding;\n        });\n    }\n\n    function hide(children) {\n        children.forEach(row => {\n            if(row.children)\n                hide(row.children);\n            row.hidden = true;\n        });\n    }\n\n    function show(children, hidden = false) {\n        children.forEach(row => {\n            if(row.children)\n                show(row.children, !row.expanded);\n            row.hidden = hidden;\n        });\n    }\n\n    // if gantt displays a bottom scrollbar and table does not, we need to pad out the table\n    let bottomScrollbarVisible;\n    $: {\n        bottomScrollbarVisible = $width > $visibleWidth && scrollWidth <= tableWidth;\n    } \n</script>\n\n<div class=\"sg-table sg-view\" style=\"width:{tableWidth}px;\">\n    <div class=\"sg-table-header\" style=\"height:{$headerHeight}px\" bind:this={headerContainer}>\n        {#each tableHeaders as header}\n            <div class=\"sg-table-header-cell sg-table-cell\" style=\"width:{header.width}px\">\n                {header.title}\n            </div>\n        {/each}\n    </div>\n\n    <div class=\"sg-table-body\" class:bottom-scrollbar-visible=\"{bottomScrollbarVisible}\">\n        <div class=\"sg-table-scroller\" use:scrollListener>\n            <div class=\"sg-table-rows\" style=\"padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;\"> \n                {#each visibleRows as row}\n                    <TableRow\n                        row={row}\n                        headers={tableHeaders}\n                        on:rowExpanded={onRowExpanded}\n                        on:rowCollapsed={onRowCollapsed}/>\n                {/each}\n            </div>\n        </div>\n    </div>\n</div>\n\n<style>\n    /* This class should take into account varying widths of the scroll bar */\n    .bottom-scrollbar-visible {\n        padding-bottom: 17px;\n    }\n\n    .sg-table {\n        overflow-x: auto;\n        display: flex;\n        flex-direction: column;\n    }\n\n    .sg-table-scroller {\n        width: 100%;\n        border-bottom: 1px solid #efefef; \n        overflow-y: hidden;\n    }\n\n    .sg-table-header {\n        display: flex;\n        align-items: stretch;\n        overflow: hidden;\n        border-bottom: #efefef 1px solid;\n        background-color: #fbfbfb;\n    }\n\n    .sg-table-rows {\n        \n    }\n\n    .sg-table-body {\n        display: flex;\n        flex: 1 1 0;\n        width: 100%;\n        overflow-y: hidden;\n    }\n\n    .sg-table-header-cell {\n        font-size: 14px;\n        font-weight: 400;\n    }\n\n    :global(.sg-table-cell){\n        white-space: nowrap;\n        overflow: hidden;\n        \n        display: flex;\n        align-items: center;\n        flex-shrink: 0;\n\n        padding: 0 .5em;\n        height: 100%;\n    }\n    \n    :global(.sg-table-cell:last-child) {\n        flex-grow: 1;\n    }\n</style>",
    "<script>\n    import {createEventDispatcher, getContext} from \"svelte\";\n\n    import TableTreeCell from './TableTreeCell.svelte';\n\n    export let headers = null;\n    export let row = null;\n\n    let tree\n\n    const {rowHeight, addButton} = getContext('options');\n    const {hoveredRow, selectedRow} = getContext('gantt');\n\n    const dispatch = createEventDispatcher();\n\n    let treeIndentationStyle = '';\n    $: {\n        treeIndentationStyle = row.parent ? `padding-left: ${row.childLevel * 3}em;` : '';\n    }\n\n    function getChildrenData(header) {\n        if (header.type === 'tree') {\n            if (row.expanded) {\n                dispatch('rowCollapsed', {row});\n            } else {\n                dispatch('rowExpanded', {row});\n            }\n            if (row.model.click) {\n                row.model.click(row)\n            }\n        }\n    }\n\n    function addTask() {\n        const {onAddButtonClick} = getContext('options');\n        onAddButtonClick(row)\n    }\n</script>\n\n<div class=\"sg-table-row {row.model.class || ''}\" style=\"height:{$rowHeight}px\" data-row-id={row.model.id}\n     class:sg-row-expanded=\"{row.expanded}\" class:sg-hover={$hoveredRow === row.model.id}\n     class:sg-selected={$selectedRow === row.model.id}>\n    {#each headers as header}\n        <div class=\"sg-table-body-cell sg-table-cell\" style=\"width:{header.width}px\">\n            <div on:click={getChildrenData(header)}>\n                {#if header.type === 'tree'}\n                    <TableTreeCell {row}>\n                        {#if row.model.iconClass}\n                            <div class=\"sg-table-icon\">\n                                <i class=\"{row.model.iconClass}\"></i>\n                            </div>\n                        {/if}\n\n                        {#if row.model.headerHtml}\n                            {@html row.model.headerHtml}\n                        {:else if header.renderer}\n                            {@html header.renderer(row)}\n                        {:else}\n                            {row.model[header.property]}\n                        {/if}\n                    </TableTreeCell>\n                {:else}\n                    {#if row.model.iconClass}\n                        <div class=\"sg-table-icon\">\n                            <i class=\"{row.model.iconClass}\"></i>\n                        </div>\n                    {/if}\n\n                    {#if row.model.headerHtml}\n                        {@html row.model.headerHtml}\n                    {:else if header.renderer}\n                        {@html header.renderer(row)}\n                    {:else if header.type === 'resourceInfo'}\n                        <img class=\"sg-resource-image\" src=\"{row.model.imageSrc}\" alt=\"\"/>\n                        <div class=\"sg-resource-title\">\n                            {row.model[header.property]}\n                        </div>\n                    {:else}\n                        {row.model[header.property]}\n                    {/if}\n                {/if}\n            </div>\n            {#if $addButton}\n                <button on:click={addTask} class=\"add-task\">+</button>\n            {/if}\n        </div>\n    {/each}\n</div>\n<style>\n    .sg-table-row {\n        display: inline-flex;\n        min-width: 100%;\n        align-items: stretch;\n\n        position: relative;\n\n        font-weight: 400;\n        font-size: 14px;\n    }\n\n    .sg-table-cell {\n        border-left: 1px solid #eee;\n    }\n\n    .sg-table-body-cell {\n        border-bottom: #efefef 1px solid;\n        background-color: #fff;\n        font-weight: bold;\n    }\n\n    .sg-resource-image {\n        width: 2.4em;\n        height: 2.4em;\n        border-radius: 50%;\n        margin-right: .6em;\n\n        background: #047c69;\n    }\n\n    .sg-resource-info {\n        flex: 1;\n        height: 100%;\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n    }\n\n    .sg-table-icon {\n        margin-right: 0.5em;\n    }\n\n    .add-task {\n        position: absolute;\n        z-index: 50;\n        float: right;\n        right:5px;\n    }\n</style>",
    "<script>\n    import { createEventDispatcher, getContext } from \"svelte\";\n\n    export let row;\n    \n    const dispatch = createEventDispatcher();\n\n    function onExpandToggle() {\n        if(row.expanded) {\n            dispatch('rowCollapsed', { row });\n        } else {\n            dispatch('rowExpanded', { row });\n        }\n    }\n</script>\n\n<div class=\"sg-cell-inner\" style=\"padding-left: {row.childLevel*3}em\">\n    {#if row.children}\n        <div class=\"sg-tree-expander\" on:click=\"{onExpandToggle}\">\n            {#if row.expanded}\n            <i class=\"fas fa-angle-down\"></i>\n            {:else}\n            <i class=\"fas fa-angle-right\"></i>\n            {/if}\n        </div>\n    {/if}\n    <slot></slot>\n</div>\n\n<style>\n    .sg-tree-expander {\n        cursor: pointer;\n        min-width: 1.4em;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n    }\n\n    .sg-cell-inner {\n        display: flex;\n    }\n</style>",
    "<script>\n    import { onMount } from 'svelte';\n\n    export let top;\n    export let left;\n    export let actions = [];\n    export let onactionend = null;\n\n    function position(point) {\n        top = point.y, left = point.x;\n    }\n\n    function execute(event, action) {\n        event.stopPropagation();\n        action.action();\n        if(onactionend) onactionend();\n    }\n\n    export function isTarget(event) {\n        return contextMenu === event.target;\n    }\n</script>\n\n<div class=\"sg-context-menu\" style=\"top:{top}px;left:{left}px\">    \n    {#each actions as action}\n        <div class=\"context-option\" on:click=\"{event => execute(event, action)}\">{action.label}</div>\n    {/each}\n</div>\n\n<style>\n    .sg-context-menu {\n        position: absolute;\n        background: white;\n        border: 1px solid #ccc;\n        padding: 0.25em 0;\n        font-size: 10px;\n        transition: opacity 0.4s ease 0s;\n        opacity: 1;\n        box-shadow: rgba(0, 0, 0, 0.32) 1px 1px 3px 0px;\n    }\n\n    .context-option:hover {\n        background: #eee;\n    }\n\n    .context-option {\n        cursor: default;\n        padding: 0.2em 1em;\n    }\n</style>",
    "<script>\n    import { createEventDispatcher, onMount } from 'svelte';\n\n    const dispatch = createEventDispatcher();\n\n    import { Draggable } from 'src/core/drag';\n    import { setCursor } from 'src/utils/domUtils';\n\n    export let x = 240;\n    export let container;\n\n    let dragging = false;\n    const dragOptions = {\n        onDrag: (event) => {\n            x = event.x, dragging = true;\n            dispatch('resize', { left: x });\n            setCursor('col-resize');\n        },\n        onDrop: (event) => {\n            x = event.x, dragging = false;\n            dispatch('resize', { left: x });\n            setCursor('default');\n        }, \n        dragAllowed: true,\n        resizeAllowed: false,\n        container: container, \n        getX: () => x,\n        getY: () => 0,\n        getWidth: () => 0\n    }\n\n    $: dragOptions.container = container;\n\n    function resizer(node) {\n        return new Draggable(node, dragOptions);\n    }\n</script>\n\n<div class=\"sg-resize\" style=\"left:{x}px\" use:resizer></div>\n<style>\n    .sg-resize {\n        z-index: 2;\n        background: #e9eaeb;\n        width: 5px;\n        cursor: col-resize;\n        position: absolute;\n        height: 100%;\n\n        transition: width 0.2s, transform 0.2s;\n    }\n\n    .sg-resize:hover {\n        transform: translateX(-2px);\n        width: 10px;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "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"
}
